from fastapi import FastAPI, HTTPException, Query
from pydantic import BaseModel, Field, field_validator
from typing import List, Optional
import json
from datetime import datetime
import os
from typing import Annotated
from pydantic import StringConstraints

DataYYYYMMDD = Annotated[
    str,
    StringConstraints(pattern=r"^\d{4}-\d{2}-\d{2}$")
]

class LancamentoBase(BaseModel):
    titulo: str = Field(..., min_length=3)
    tipo: str
    valor: float = Field(..., ge=0)
    data: DataYYYYMMDD
    descricao: Optional[str] = None

app = FastAPI(
    title="Gerenciador Simples de Salário e Gastos",
    description="API para controlar salário e despesas mensais",
    version="1.0"
)

ARQUIVO = "lancamentos.json"

TIPOS_VALIDOS = ["salario", "freela", "vale", "outros_entrada", "alimentacao", "transporte", "moradia", "lazer", "estudos", "saude", "outros_gasto"]
MESES_VALIDOS = list(range(1, 13))

def carregar_dados() -> List[dict]:
    if not os.path.exists(ARQUIVO):
        return []
    try:
        with open(ARQUIVO, "r", encoding="utf-8") as f:
            return json.load(f)
    except:
        return []

def salvar_dados(dados: List[dict]):
    with open(ARQUIVO, "w", encoding="utf-8") as f:
        json.dump(dados, f, ensure_ascii=False, indent=2)

lancamentos_db = carregar_dados()
proximo_id = max([item["id"] for item in lancamentos_db], default=0) + 1


#modelo

class LancamentoBase(BaseModel):
    titulo: str = Field(..., min_length=3, description="Ex: Salário JAN/26, Netflix, Supermercado")
    tipo: str
    valor: float = Field(..., ge=0, description="Valor positivo sempre")
    data: str = Field(..., pattern=r"^\d{4}-\d{2}-\d{2}$", description="Formato YYYY-MM-DD")
    descricao: Optional[str] = None

    @field_validator("tipo")
    @classmethod
    def validar_tipo(cls, v):
        if v not in TIPOS_VALIDOS:
            raise ValueError(f"Tipo inválido. Opções: {', '.join(TIPOS_VALIDOS)}")
        return v

    # O validator de data pode ser mantido ou removido (o pattern já valida o formato)
    @field_validator("data")
    @classmethod
    def validar_data(cls, v):
        try:
            datetime.strptime(v, "%Y-%m-%d")
            return v
        except ValueError:
            raise ValueError("Data inválida. Use formato YYYY-MM-DD")

class LancamentoCreate(LancamentoBase):
    pass

class LancamentoUpdate(LancamentoBase):
    pass

class Lancamento(LancamentoBase):
    id: int



@app.get("/lancamentos", response_model=List[Lancamento])
def listar_lancamentos(
    tipo: Optional[str] = Query(None, description="Filtrar por tipo"),
    mes: Optional[int] = Query(None, ge=1, le=12),
    ano: Optional[int] = Query(None, ge=2020),
):
    resultado = lancamentos_db.copy()

    if tipo:
        resultado = [item for item in resultado if item["tipo"] == tipo]

    if mes and ano:
        resultado = [
            item for item in resultado
            if item["data"].startswith(f"{ano}-{mes:02d}")
        ]
    elif ano:
        resultado = [
            item for item in resultado
            if item["data"].startswith(f"{ano}-")
        ]

    return resultado


@app.get("/lancamentos/{id}", response_model=Lancamento)
def obter_um(id: int):
    for item in lancamentos_db:
        if item["id"] == id:
            return item
    raise HTTPException(status_code=404, detail="Lançamento não encontrado")


@app.post("/lancamentos", response_model=Lancamento, status_code=201)
def criar_lancamento(lanc: LancamentoCreate):
    global proximo_id

    novo = lanc.dict()
    novo["id"] = proximo_id
    proximo_id += 1

    lancamentos_db.append(novo)
    salvar_dados(lancamentos_db)

    return novo


@app.put("/lancamentos/{id}", response_model=Lancamento)
def atualizar_lancamento(id: int, lanc: LancamentoUpdate):
    for item in lancamentos_db:
        if item["id"] == id:
            item.update(lanc.dict(exclude_unset=True))
            salvar_dados(lancamentos_db)
            return item
    raise HTTPException(status_code=404, detail="Lançamento não encontrado")


@app.delete("/lancamentos/{id}")
def remover_lancamento(id: int):
    global lancamentos_db
    novo_db = [item for item in lancamentos_db if item["id"] != id]
    if len(novo_db) == len(lancamentos_db):
        raise HTTPException(status_code=404, detail="Lançamento não encontrado")
    lancamentos_db = novo_db
    salvar_dados(lancamentos_db)
    return {"message": "Lançamento removido com sucesso"}


@app.get("/resumo")
def ver_resumo(
    mes: int = Query(..., ge=1, le=12, description="Mês (1-12)"),
    ano: int = Query(..., ge=2020, description="Ano (ex: 2026)")
):
    itens = [
        item for item in lancamentos_db
        if item["data"].startswith(f"{ano}-{mes:02d}")
    ]

    entradas = sum(item["valor"] for item in itens if item["tipo"] in ["salario", "freela", "vale", "outros_entrada"])
    saidas = sum(item["valor"] for item in itens if item["tipo"] not in ["salario", "freela", "vale", "outros_entrada"])

    return {
        "mes_ano": f"{mes:02d}/{ano}",
        "total_entradas": round(entradas, 2),
        "total_saidas": round(saidas, 2),
        "saldo": round(entradas - saidas, 2),
        "quantidade_lancamentos": len(itens),
        "detalhes": itens
    }


@app.get("/tipos")
def listar_tipos_permitidos():
    return {"tipos_validos": TIPOS_VALIDOS}
